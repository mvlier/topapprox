'''
Basin Hierarchy Tree class
'''

import numpy as np
import re


class BasinHierarchyTree():
    """
    Class representing a Basin Hierarchy Tree (BHT).

    The Basin Hierarchy Tree is designed for topological data analysis, primarly for
    applying topological filters to data. 

    Attributes:
    ----------
    parent : np.array or None
        The array of parent nodes for each vertex in the tree.
    children : list of lists or None
        The list of children for each vertex in the tree.
    persistent_children : list of lists or None
        The list of children for each vertex that are relevant for persistence calculations.
    positive_pers : np.array or None
        A 1D array of vertices that have positive persistence values (excluding the root).
    birth : np.array or None
        The array containing birth times for each vertex in the BHT.
    linking_vertex : np.array or None
        An array of linking vertices that connect each vertex to its parent during persistence calculations.
    root : int or None
        The index of the root vertex in the tree.
    persistence : np.array or None
        The precomputed persistence diagram. If not already computed, it will be generated by the `get_persistence` method.

    Methods:
    -------
    __init__()
        Initializes an empty Basin Hierarchy Tree with no data.
    
    _low_pers_filter(epsilon)
        Applies a topological low-persistence filter to the tree, removing cycles with persistence lower than `epsilon`.

    _lpf_size_filter(epsilon, size_range=[0, np.inf])
        Filters basins based on their persistence and size, applying a threshold for both persistence and size.

    filter_branch(vertex, epsilon, modified)
        Recursively filters a branch of the tree, modifying the birth times of vertices with persistence below `epsilon`.

    basin_size(vertex)
        Returns the size of a basin for a given vertex, including the vertex and all its descendants.

    get_persistence(reduced=True)
        Computes the persistence diagram for the tree, optionally returning the reduced form excluding the root's infinite interval.

    _get_BHT(with_children=False)
        Retrieves the structure of the tree, including parent-child relationships, linking vertices, and optionally children of each node.

    get_descendants(v)
        Returns all descendants of a given vertex `v`.

    descendants(v, desc)
        Recursively appends descendants of a vertex `v` to the provided list `desc`.

    """
    def __init__(self, *, recursive=True) -> None:
        self.parent = None
        self.children = None
        self.persistent_children = None
        self.positive_pers = None # 1D numpy array to store the list of vertices with positive persistence, apart from the root
        self.birth = None
        self.linking_vertex = None
        self.root = None
        self.persistence = None
        self.recursive = recursive
        self.get_descendants = self.get_descendants_recursive if recursive else self.get_descendants_iterative
        self._describe_pers = None


    def _low_pers_filter(self, epsilon):
        """ computes topological low-persistence-filtering
        Args:
            epsilon (float): cycles having persistence below this value will be eliminated
        Returns:
            np.array: a filtered image
        """
        # print(f'''BHT:
        #       Birth: {self.birth}
        #       Parent: {self.parent}
        #       Pers_child: {self.persistent_children}
        #       Linking: {self.linking_vertex}''')
        self.epsilon = epsilon
        modified = self.birth.copy()
        for vertex in self.persistent_children[self.root]:
            self.filter_branch(vertex, self.epsilon, modified)
        return(modified)
    
    def _lpf_size_filter(self, epsilon, size_range = [0, np.inf]):
        """
        Applies the low persistence filter considering the size of the basins.

        This method modifies the 'birth' array by filtering vertices based on persistence
        and the size of their basins. Only basins whose sizes fall within the specified 
        range (`size_range`) and are bellow the specified threshold (`epsilon`) are processed.

        Parameters:
        ----------
        epsilon : float
            The threshold for the low persistence filter.
        size_range : list, optional
            A two-element list specifying the minimum and maximum sizes of basins to 
            be filtered. The default range is [0, np.inf], meaning all basins are considered.

        Returns:
        -------
        modified : np.array
            A modified version of the 'birth' array, where the birth times of vertices
            within the specified size gap are updated based on their parent vertex's 
            birth time.
        """
        self.epsilon = epsilon
        modified = self.birth.copy()
        for vertex in self.persistent_children[self.root]:
            self.filter_branch_with_size(vertex, self.epsilon, modified, size_range=size_range)
        return(modified)
    
        
    def filter_branch(self, vertex, epsilon, modified):
        """
        Recursively filters branches in the Basin Hierarchy Tree (BHT) based on persistence.

        Given a `vertex`, this method modifies the `modified` array by eliminating classes 
        in the branch of the vertex whose positive persistence is lower than a threshold 
        `epsilon`. If the persistence of a vertex is greater than or equal to `epsilon`, 
        the function proceeds to filter its children recursively.

        Parameters:
        ----------
        vertex : int
            The index of the vertex in the BHT to start filtering from.
        epsilon : float
            The persistence threshold. Branches with persistence lower than this value 
            will be filtered.
        modified : np.array
            The array that will be updated during the filtering process, where filtered 
            vertices have their birth times replaced by their linking vertex's birth time.
        
        Returns:
        -------
        None
        """
        linking_vertex = self.linking_vertex[vertex]
        persistence = self.birth[linking_vertex] - self.birth[vertex]
        if  0 < persistence < epsilon:
            modified[np.array(self.get_descendants(vertex))] = self.birth[linking_vertex]
        elif persistence >= epsilon:
            for child_vertex in self.persistent_children[vertex]:
                self.filter_branch(child_vertex, epsilon, modified)

    
    def filter_branch_with_size(self, vertex, epsilon, modified, *, size_range=[0,np.inf]):
        """
        filter branch considering basin size
        """
        linking_vertex = self.linking_vertex[vertex]
        persistence = self.birth[linking_vertex] - self.birth[vertex]
        if  0 < persistence < epsilon:
            desc = np.array(self.get_descendants(vertex))
            size = len(desc)
            if size_range[0] <= size: 
                if size <= size_range[1]:
                    modified[desc] = self.birth[linking_vertex]
                else:
                    for child_vertex in self.persistent_children[vertex]:
                        self.filter_branch_with_size(child_vertex, epsilon, modified, size_range=size_range)
        elif persistence >= epsilon:
            for child_vertex in self.persistent_children[vertex]:
                self.filter_branch_with_size(child_vertex, epsilon, modified, size_range=size_range)


    def basin_size(self, vertex):
        """
        Returns the size of the basin associated with a given `vertex`.

        A basin is composed of the vertex itself and all of its descendants in the BHT.

        Parameters:
        ----------
        vertex : int
            The index of the vertex for which the basin size is calculated.

        Returns:
        -------
        int
            The size of the basin, which is the number of the vertex's descendants plus the vertex itself.
        """
        return len(self.get_descendants(vertex))
    

    def get_persistence(self, *, reduced=True):
        """
        Computes the persistence diagram for the Basin Hierarchy Tree (BHT).

        The persistence diagram consists of tuples representing (birth, death, birth_location, death_location, basin_size).
        If `reduced` is False, the root's infinite interval is also included in the diagram.

        Parameters:
        ----------
        reduced : bool, optional
            If True, the diagram excludes the root's infinite interval (default is True).

        Returns:
        -------
        np.array
            The computed persistence diagram as an array, with each entry corresponding to 
            a persistence pair (birth, death, birth_location, death_location, basin_size).
        """

        # if not self.persistence is None:
        #     return self.persistence

        #(birth, death, birth_location, death_location, basin_size, depth, height)
        self.persistence = np.array([[self.birth[v], self.birth[self.linking_vertex[v]], v, 
                                      self.linking_vertex[v], self.basin_size(v), self.get_depth(v), 
                                      self.get_positive_pers_height(v)] for v in self.positive_pers])
        self._describe_pers = """[birth, death, birth_vertex, death_vertex, basin_size, depth_in_BHT, height_in_BHT]

            birth:..............birth time of cycle.
            death:..............death time of cycle.
            birth_vertex:.......vertex that initiated the cycle.
            death_vertex:.......the linking vertex that killed the cycle by merging it with an older component.
            basin_size:.........size of the cycle (number of vertices in the component before merging).
            depth_in_BHT:.......the distance of the birth_vertex to the root of the BHT.
            height_in_BHT:......the biggest distance from the birth_vertex to a leaf in the subtree of BHT 
                                having only vertices with positive persistence."""

        if reduced==False:
            permanent_interval = np.array([[self.birth[self.root], np.inf, self.root, -1, np.inf, self.get_depth(self.root), 
                                      self.get_positive_pers_height(self.root)]])
            self.persistence = np.concatenate((self.persistence, permanent_interval))
        
        return self.persistence
    
    def describe_pers(self):
        """
        Prints the description of the persistence diagram obtained with `self.get_persistence()`.
        """
        print(self._describe_pers)

    
    def _get_BHT(self, *, with_children=False):
        """
        Retrieves the Basin Hierarchy Tree (BHT) structure.

        Returns the list of parents, linking vertices, and the root of the tree. If `with_children` 
        is True, also returns the list of children for each vertex in the tree.

        Parameters:
        ----------
        with_children : bool, optional
            If True, the children of each node are returned in the output (default is False).

        Returns:
        -------
        tuple
            A tuple containing (parents, linking_vertex, root). If `with_children` is True, 
            the children of each node are also included.
        """
        if self.children == None:
            print("BHT is empty")
            return None
        if with_children:
            return self.parent, self.linking_vertex, self.root, [list(x) for x in self.children]
        return self.parent, self.linking_vertex, self.root
    

    def get_descendants_recursive(self, v):
        """
        Returns a list of all descendants of a given vertex `v`.

        Parameters:
        ----------
        v : int
            The vertex for which to retrieve descendants.

        Returns:
        -------
        list
            A list of vertex indices that are descendants of `v`.
        """
        desc = []  
        self.descendants(v, desc)  
        return desc


    def descendants(self, v, desc):
        """
        Recursively collects all descendants of a vertex `v` into the list `desc`.

        Parameters:
        ----------
        v : int
            The current vertex being processed.
        desc : list
            A list that accumulates the descendants of `v`.
        
        Returns:
        -------
        None
        """
        desc.append(v)  # Append the current node
        for child in self.children[v]:  # Use a loop to iterate over the children
            self.descendants(child, desc)  # Recursively find descendants


    def get_descendants_iterative(self, v):
        """
        Iteratively collects all descendants of a vertex `v`.

        Parameters:
        ----------
        v : int
            The vertex for which to retrieve descendants.

        Returns:
        -------
        list
            A list of vertex indices that are descendants of `v`.
        """
        descendants = []
        stack = [v]  # Stack to manage the traversal (DFS)
        
        while stack:
            current = stack.pop()  # Process the next vertex
            descendants.append(current)  # Add the current vertex to the list
            stack.extend(self.children[current])  # Add children to the stack for further exploration
        
        return descendants

    #TODO: maybe this part can be optimized
    # One option is to directly include the computation of depth in the 
    # link-reduce algorithm
    def get_depth(self, vertex):
        """
        Returns the depth of `vertex` in the BHT.
        The depth in this case is the distance to the root.
        E.g., the root has depth 0, its children depth 1, 
        grandchildren depth 2, and so on.

        Parameter:
        ---------
        vertex : int
                 The vertex for which to receive the depth
        
        Returns:
        -------
        int
            The value of the depth of `vertex`
        """
        depth = 0
        while self.parent[vertex] != vertex:
            vertex = self.parent[vertex]
            depth += 1
        return depth
    
    #TODO: maybe this part can be optimized
    # One option is to directly include the computation of depth in the 
    # link-reduce algorithm
    def get_height(self, vertex):
        """
        Returns the height of `vertex` in the BHT.
        The height is the maximum distance from `vertex` to a leaf in the 
        descendants of `vertex`.

        E.g., leafs have height 0, vertices with all children being leafs
        have height 1, and vertices with all children being leafs or vertices of 
        height 1 have height 2.

        Parameter:
        ---------
        vertex : int
                 The vertex for which to compute the height

        Returns:
        -------
        int
            The value of the height of `vertex`
        """
        # If the vertex has no children, its height is 0 (leaf node)
        if len(self.children[vertex]) == 0:
            return 0
        # Recursively compute the height of the vertex by finding the max height among its children
        return 1 + max(self.get_height(child) for child in self.children[vertex])
    
    def get_positive_pers_height(self, vertex):
        """
        Returns the height of `vertex` in the subtree 
        of positive persistence nodes of the BHT.

        Parameter:
        ---------
        vertex : int
                 The vertex for which to compute the height

        Returns:
        -------
        int
            The value of the height of `vertex`
        """
        # If the vertex has no children, its height is 0 (leaf node)
        if len(self.persistent_children[vertex]) == 0:
            return 0
        # Recursively compute the height of the vertex by finding the max height among its children
        return 1 + max(self.get_positive_pers_height(child) for child in self.persistent_children[vertex])
    
    
    ################################################################################
    #                         \_____________|____________/                         #
    #_/‾\_/‾\_/‾\_/‾\_/‾\_/‾\_|SUMMARY STATISTICS METHODS|_/‾\_/‾\_/‾\_/‾\_/‾\_/‾\_#
    #                         /‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾\                         #
    ################################################################################

    def check_persistence_exists(self):
        '''
        Checks if the persistence diagram was already computed and
        is stored in `self.persistence`, if not it calls the `get_persistence`
        method, to compute the persistence diagram and store it.
        '''

        if self.persistence is None:
            _ = self.get_persistence()


    def _get_weight(self, weight_name):
        '''
        Weight functions for computing the depth and height distributions.

        Parameter:
        ---------
        weight_name: None or str or np.ndarray
        '''
        pd = self.persistence
        if weight_name is None:
            return 1
        elif isinstance(weight_name, np.ndarray):
            return weight_name
        elif weight_name == "basin_size":
            return pd[:,4]
        elif weight_name == "persistence":
            return np.diff(pd[:,0:2])
        elif weight_name == "basin_size_x_persistence":
            return np.diff(pd[:,0:2])*pd[:,4]
        elif len(weight_name)>24 and weight_name[:24] == "basin_size_+_persistence":
            pattern = r"basin_size_\+_persistence\(([\d.]+),([\d.]+)\)"
            match = re.search(pattern, weight_name)
            if match:
                a = float(match.group(1))
                b = float(match.group(2))
                return a*pd[:,4] + b*np.diff(pd[:,0:2])
            else:
                raise ValueError(f"Expected the end of the string to be '(number1, number2)', but received {weight_name[24:]}")
            



    def depth_distribution(self, *, depth_range=None, ratio=False, weight=None):
        '''
        Returns a numpy array of shape (n,)
        in which the i-th entry (array[i]) corresponds to the 
        total number of persistence intervals with depth i+1.

        E.g.,
        [depth==1, depth==2, ..., depth==n]

        If `depth_range` is not None, then the returned numpy array
        has the shape (depth_range[1]-depth_range[0]) and 
        is of the following form:

        [depth==depth_range[0], depth==depth_range[0]+1, ..., depth==depth_range[1]]

        Parameter:
        ---------
        depth_range: tuple of length 2
                     lower and upper bound for the depths to be included in the depth
                     distribution array.
        ratio: bool
               if True, the distribution is converted to a ratio, thus the i-th entry
               represents the percentage of elements with that depth.
        weight: str
                the name of the weight to be used. If None, the weight is det to be
                constant equal to 1. 
                Other options are:
                                "basin_size":  weight by basin size of cycle
                                "persistence": weight by persistence of cycle
        
        Returns:
        -------
        depth_distr: np.ndarray
                    An array containing the number of intervals in the persistence diagram
                    for each depth in the range `depth_range`.
        '''
        self.check_persistence_exists()
        pd = self.persistence
        weight = self._get_weight(weight)
        if depth_range is None:
            depth_range = [1, int(np.max(pd[:,5]))] # standard range
        depth_distr =  np.array([np.sum((pd[:,5] == i)*weight) 
                         for i in range(depth_range[0], depth_range[1]+1)])
        N = np.sum(depth_distr) if ratio else 1
        return depth_distr/N
    

    def height_distribution(self, *, height_range=None, ratio=False, weight=None):
        '''
        Returns a numpy array of shape (n,)
        in which the i-th entry (array[i]) corresponds to the 
        total number of persistence intervals with height i.

        E.g.,
        [height==0, height==1, ..., height==n]

        If `height_range` is not None, then the returned numpy array
        has the shape (height_range[1]-height_range[0]) and 
        is of the following form:

        [height==height_range[0], height==height_range[0]+1, ..., height==height_range[1]]

        Parameter:
        ---------
        height_range: tuple of length 2
                     lower and upper bound for the heights to be included in the height
                     distribution array.
        ratio: bool
               if True, the distribution is converted to a ratio, thus the i-th entry
               represents the percentage of elements with that height.
        
        Returns:
        -------
        height_distribution: np.ndarray
                            An array containing the number of intervals in the persistence diagram
                            for each height in the range `height_range`.
        '''
        self.check_persistence_exists()
        pd = self.persistence
        weight = self._get_weight(weight)
        if height_range is None:
            height_range = [0, int(np.max(pd[:,6]))] # standard range
        height_distr = np.array([np.sum((pd[:,6] == i)*weight) 
                         for i in range(height_range[0], height_range[1]+1)])
        N = np.sum(height_distr) if ratio else 1
        return height_distr/N


